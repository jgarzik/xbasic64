# ==============================================================================
# BASIC Runtime: DATA/READ/RESTORE Support (Win64 Native - Pure Win32 API)
# ==============================================================================
#
# Functions implementing BASIC's DATA/READ/RESTORE statements.
# Uses UCRT strtod for string-to-number conversion.
#
# Data Table Format:
#   Each entry is 16 bytes:
#   Offset  Size  Content
#   ------  ----  -------
#   0       8     Type tag: TYPE_INTEGER, TYPE_FLOAT, or TYPE_STRING
#   8       8     Value: integer, double bits, or string pointer
#
# Global State:
#   _data_table = Array of 16-byte entries (generated by compiler)
#   _data_count = Number of entries in table
#   _data_ptr   = Current read position (0-based index)
#
# Win64 ABI:
#   - Args: rcx, rdx, r8, r9
#   - 32-byte shadow space required before calls
# ==============================================================================

# DATA type tags
.equ TYPE_INTEGER, 0
.equ TYPE_FLOAT,   1
.equ TYPE_STRING,  2

# ------------------------------------------------------------------------------
# _rt_read_number - Read next DATA value as a number
# ------------------------------------------------------------------------------
# Reads the next value from the DATA table and returns it as a double.
#
# Arguments: none
#
# Returns:
#   xmm0 = value as double
# ------------------------------------------------------------------------------
.globl _rt_read_number
_rt_read_number:
    push rbp
    mov rbp, rsp
    sub rsp, 32                         # Shadow space

    # Calculate address: &_data_table[_data_ptr]
    mov rax, QWORD PTR [rip + _data_ptr]
    shl rax, 4                          # offset = index * 16
    lea rcx, [rip + _data_table]
    add rcx, rax                        # rcx = entry address

    # Load type tag
    mov rax, QWORD PTR [rcx]            # rax = type tag
    cmp rax, TYPE_STRING
    je .Lread_str_as_num                # string needs special handling

    # Load value (works for both int and float)
    movsd xmm0, QWORD PTR [rcx + 8]
    cmp rax, TYPE_INTEGER
    jne .Lread_num_done                 # if float, we're done

    # Integer: convert to double
    mov rax, QWORD PTR [rcx + 8]        # load as integer
    cvtsi2sd xmm0, rax                  # convert to double

.Lread_num_done:
    inc QWORD PTR [rip + _data_ptr]     # advance to next entry
    leave
    ret

.Lread_str_as_num:
    # String: parse with strtod
    mov rcx, QWORD PTR [rcx + 8]        # string pointer
    xor rdx, rdx                        # endptr = NULL
    call strtod                         # returns double in xmm0
    inc QWORD PTR [rip + _data_ptr]     # advance to next entry
    leave
    ret

# ------------------------------------------------------------------------------
# _rt_read_string - Read next DATA value as a string
# ------------------------------------------------------------------------------
# Reads the next value from the DATA table and returns it as a string.
#
# Arguments: none
#
# Returns:
#   rax = pointer to string data
#   rdx = string length
# ------------------------------------------------------------------------------
.globl _rt_read_string
_rt_read_string:
    push rbp
    mov rbp, rsp
    push rdi                            # rdi is callee-saved
    sub rsp, 40                         # Shadow space + alignment

    # Calculate entry address
    mov rax, QWORD PTR [rip + _data_ptr]
    shl rax, 4                          # offset = index * 16
    lea rcx, [rip + _data_table]
    add rcx, rax                        # rcx = entry address

    # Load string pointer and save for later
    mov rdi, QWORD PTR [rcx + 8]        # rdi = string pointer

    # Calculate length using lstrlenA (Win32 API)
    mov rcx, rdi
    call lstrlenA                       # returns length in eax

    mov rdx, rax                        # length → rdx
    mov rax, rdi                        # string pointer → rax

    # Advance to next entry
    inc QWORD PTR [rip + _data_ptr]

    add rsp, 40
    pop rdi
    leave
    ret

# ------------------------------------------------------------------------------
# _rt_restore - Reset DATA pointer (RESTORE statement)
# ------------------------------------------------------------------------------
# Resets the DATA read position.
#
# Arguments:
#   rcx = new position (0-based index into data table)
#
# Returns: nothing
# ------------------------------------------------------------------------------
.globl _rt_restore
_rt_restore:
    mov QWORD PTR [rip + _data_ptr], rcx
    ret

